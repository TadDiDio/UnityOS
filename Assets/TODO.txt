WHEN WE LAST LEFT OFF...
Things are generally untested and the tests I do have are old, but the system appears very robust and there were no 
code smells. Testing is only worth it if selling this product, otherwise its not worth the immense time sink. Remember 
that when making new things, can you register defaults for anything you want using an IConsoleInstaller. There is no 
protection against prompting in a non interactive context, but currently all contexts are interactive and file running 
is contained to terminals so this feature was not worth protecting against yet. When prompting for commands, we can only 
convert string -> XXX so a gui will need to build a command batch fully and submit it like that (or use a string, but
that is not proper for a gui which can build commands directly). Currently command separators ";" and "&&" are hardcoded 
in TokenCommandResolver.cs and DefaultBatcher. Eventually this should be moved to a config file or at last a common place.
CommandWindow and TerminalClient duplicate a lot of graphics so that should be refactored eventually. Most of the windowing
was done quickly to get the project ready. The UserInterface may be close to redundant to IHumanInterface but the 
redirection of interfacing works properly. The terminal hiding is a special case embedded in the terminal client right now
because of the absurd difficulties in working with unitys stupid ass Event.current system. Basically it looks like the 
GUILayout.Window class is absorbing it before the OnGui methods are being run somehow.



ROSLYN:
Check attributes on bad types, i.e. Subcommand only allowed on ICommand objects
Check that positional indexes are different
UnlimitedArgsAttribute is only used on IEnumerable fields
Only one UnlimitedArgsAttribute
Required is only for switch, all positional are always required
Making a switch with the same long or short name
Missing Command attribute on command class
preserve attribute for anything with [Command] on it and for IConsoleInstaller classes.
mutual exclusion between command and subcommand attributes

THINGS TO TEST
adaptFromString for each adapter
optional parse rule
command executor
Command Meta processor
shell application
shell session (not complete)
file source 
input manager
output manager
API
pre execution validators - Requires async testing
object bindings manager and attribute
message formatter (if used, i would wait on this one)
MAKE SURE ALL TESTS INHERIT FROM CONSOLE TEST


NEXT UP:
Remove Subcommand attribute and allow nesting in parent commands.
Multiple command input via ; and similar dividers
Add support for nested REPL style commands in shell sessions
Windowing system for multiple terminals or custom windowed commands
Maintain session state consistency per environment (editor, build), not across both, multi console state tracking via files
Permissions system (hooked via precommand validator)
If you make a abstract UI system, do an abstract input system too.
Choice functionality in shell to help common input choices that are limited to range. Should support modal GUI later too.
Auto completion system with rich typed positional arg hints in CLI
Change NoPrompt flag in shell request to be a filter rather than an all-off switch

FEATURES TO GET TO
Need to make a system wide Isready event before accessing resources or running commands to give users a chance to register stuff before commands are run.
Template script for making new commands
Allow users to apply/override global command name and description processing for consistency
Allow command groups for better output in reg command
Allow users to register type parsers in a single spot if they prefer, something like GlobalTypeParserRegistration.
Create auto test harness to allow users to quickly test their commands.
Async command discovery process removes the need for manual registration which would be absolutely attrocious
Pipe unity log to console
unified vs per shell log
reset terminal command which resets console state to default if a user fucks it
Command for runtime ui construction with possible save as editor window functionality for persistence :o
Command playback to get to same point in play mode fast
VOICE COMMAND SYSTEM?????
DOMAIN SPECIFIC LLM??????

NOTES FOR DOCS
- Commands are stored in registry using their fully qualified name i.e. parent.sub.subsub so that multiple subcommands 
    can have the same root name without conflicts. Make sure to use the fully qualified name if doing a query (users will
    very rarely if ever need to query though)
- Need to fully document binding behaviors
- Command declaration and attributes
- Mention that if you have a hard time formatting command with built in options, consider making a sub command or two for it.
- Weird error case: unexpected token appearing after positionals but before a switch on a command which accepts variadic 
    args may display a required validation error despite having the switch because the unexpected token started the 
    variadic processing. Technically this error is correct but its unclear.
- don't need to add new() for subcommands and its better if you dont because the needed ones will be automatically instantiated.
- Message formatter exists :)
- Parse rules and their priorities, lower = higher priority
- When a session is waiting for input, it expects a text input and everything else will be ignored.
- All inputs can be promoted to command requests.
- To use the test system, you must make sure to register a custom attribute builder if you are testing it. Note how this works with empty and non empty constructors.
- recommend inheriting test classes from ConsoleTest since it reboots the system before and after the test runs.
- If adding more than one field to a test type, give them distinct names or they will all default to "test"
- Safe to return null for none matches in IParseRules
- If I add an option for auto killing commands when play mode exits, change the async docs at the bottom of Custom Commands to reflect it.
- How to make validated attributes and new arg declaration attributes
- Remember to reset the next input type after using it from a PromptedFor in a shellclient.
- When making type adapters make sure to consume all tokens used (or read to be safe). Changes you make are isolated and will only be applied on a success.
- Inputting types from CLI must use fully qualified name (verify this).
- If making own client, responses to a choice prompt should either be adaptable to one from the list or directly one from the list.
- When using variadic args, make sure to initialize the list using new(). If you don't the system will only initialize it when you provide variadic args on the command line.
- You can make flags true by default and disabled with --no-flag or -no-f by simply setting bool to true like [...] private bool flag = true;
- Make sure to allow OperationCancelledExceptions to propagate in commands or else unexpected things may happen.
- Commands that take in other commands can use a Command Batch object but that must appear at the end of the input since it will absorb all remaining text

COMMAND IDEAS
bind
list (debugs helpful fields on all types in the scene maybe)